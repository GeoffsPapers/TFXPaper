\documentclass{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{amsfonts,dsfont}
\usepackage{fancyvrb}
\usepackage[show]{ed}
\setlength{\tabcolsep}{5pt}

%\newenvironment{packed_itemize}{
%\vspace*{-0.5em}
%\begin{itemize}
%  \setlength{\partopsep}{0pt}
%  \setlength{\itemsep}{1pt}
%  \setlength{\parskip}{0pt}
%  \setlength{\parsep}{0pt}
%}{\end{itemize}}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,morekeywords={if,assert}}

\begin{document}
\title{TFX: The TPTP Extended Typed First-order Form}
\titlerunning{TFX}
\author{
    Geoff Sutcliffe\inst{1}
\and
    Evgenii Kotelnikov\inst{2}
}
\institute{
   University of Miami, USA
\and
   Chalmers University of Technology, Sweden
}
\authorrunning{Sutcliffe, Kotelnikov}
\clearpage
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
The TPTP world is a well established infrastructure that supports research, 
development, and deployment of Automated Theorem Proving (ATP) systems for 
classical logics. 
The TPTP language is one of the keys to the success of the TPTP world. 
Originally the TPTP world supported only first-order clause normal form (CNF). 
Over the years support for full first-order form (FOF), monomorphic typed 
first-order form (TF0), rank-1 polymorphic typed first-order form (TF1), 
monomorphic typed higher-order form (TH0), and rank-1 polymorphic typed 
higher-order form (TH1), have been added. 
TF0 and TF1 together form the TFF language family; TH0 and TH1 together form 
the THF language family. 
Since the inception of TFF there have been some features that have received 
little use, and hence little attention, such as tuples, conditional 
expressions (if-then-else), and let expressions. 
This paper introduces the Typed First-order eXtended form (TFX), which extends
TFF to include these and other features. 
\end{abstract}

\newcommand{\binding}[2]{{#1}={#2}}
\newcommand{\ite}[3]{\mathtt{if}\;{#1}\;\allowbreak\mathtt{then}\;{#2}\;\allowbreak\mathtt{else}\;{#3}}
\newcommand{\letin}[3]{\mathtt{let}\;\binding{#1}{#2}\;\allowbreak\mathtt{in}\;{#3}}
\newcommand{\letinpar}[5]{\mathtt{let}\;\binding{#1}{#2};\;\binding{#3}{#4}\;\mathtt{in}\;{#5}}
\newcommand{\letindef}[2]{\mathtt{let}\;{#1}\;\allowbreak\mathtt{in}\;{#2}}
\newcommand{\letnl}[3]{\begin{aligned}[t]\mathtt{let}\;&\binding{#1}{#2}\\[-0.2em]\mathtt{in}\;&{#3}\end{aligned}}
\newcommand{\letinnl}[3]{\begin{aligned}[t]&\mathtt{let}\;\binding{#1}{#2}\;\mathtt{in}\\[-0.2em]&\quad{#3}\end{aligned}}
\newcommand{\itenll}[3]{\begin{aligned}[t]&\mathtt{if}\;{#1}\\[-0.2em]&\mathtt{then}\;{#2}\\[-0.2em]&\mathtt{else}\;{#3}\end{aligned}}
\newcommand{\tuple}[1]{({#1})}

\renewcommand{\implies}{\Rightarrow}
\newcommand{\liff}{\Leftrightarrow}
\newcommand{\lniff}{\not\Leftrightarrow}
\newcommand{\bool}{\mathit{bool}}

%------------------------------------------------------------------------------
\section{Introduction}
\label{Introduction}

The TPTP world \cite{Sut10} is a well established infrastructure that supports
research, development, and deployment of Automated Theorem Proving (ATP)
systems for classical logics.
The TPTP world includes the TPTP problem library,
% \cite{Sut09}, 
the TSTP solution library,
% \cite{Sut10}, 
the TMTP model library,
% \cite{SS16},
standards for writing ATP problems and reporting ATP solutions,
% \cite{SS+06,Sut08-KEAPPA}, 
tools and services for processing ATP problems and solutions,
% \cite{Sut10}, 
and it supports the CADE ATP System Competition (CASC).
% \cite{Sut16}.
Various parts of the TPTP world have been deployed in a range of applications,
in both academia and industry.
The web page \url{http://www.tptp.org} provides access to all components.

The TPTP language is one of the keys to the success of the TPTP world.
The language is used for writing both TPTP problems and TSTP solutions,
which enables convenient communication between different systems and
researchers.
Originally the TPTP world supported only first-order clause normal form (CNF)
\cite{SS98-JAR}.
Over the years support for full first-order form (FOF) \cite{Sut09},
monomorphic typed first-order form (TF0) \cite{SS+12}, rank-1 polymorphic
typed first-order form (TF1) \cite{BP13-TFF1}, monomorphic typed higher-order 
form (TH0) \cite{SB10}, and rank-1 polymorphic typed higher-order form (TH1) 
\cite{KSR16}, have been added.
TF0 and TF1 together form the TFF language family; TH0 and TH1 together form 
the THF language family.

Since the inception of TFF there have been some features that have 
received little use, and hence little attention. 
In particular, tuples, conditional expressions (if-then-else), and let 
expressions (let-defn-in) were neglected, and the latter two were horribly 
formulated with variants to distinguish between their use with formulae and 
terms. 
Recently, conditional expressions and let expressions have become more 
important because of their use in software verification applications.
In an independent development, Evgenii Kotelnikov et al. introduced
FOOL~\cite{KKV15}, a variation of many-sorted first-order logic (FOL).
FOOL extends the ordinary FOL in that it (i)~contains an interpreted boolean
sort and allows formulae to be used as boolean terms, (ii)~allows boolean
variables to be used as formulae, (iii)~contains conditional expressions, and
(iv)~contains let expressions with definitions of function symbols, predicate
symbols, and tuples. 
FOOL can be extended with the theory of tuples~\cite{KKV18}
that contains first class tuple terms and first class tuple types. 
Features of FOOL can be used to concisely express problems coming from program
analysis~\cite{KKV18} or translated from more expressive logics. 
Conditional expressions and let expressions of FOOL resemble those of the 
SMT-LIB language version 2~\cite{BST10}.

The TPTP's new Typed First-order form eXtended (TFX) language remedies the
old weaknesses of TFF, and incorporates the features of FOOL.
This has been achieved by conflating (with some exceptions) formulae and 
terms, simplifying tuples in plain TFF, including fully expressive tuples in 
TFX, removing the old conditional expressions and let expressions from 
TFF, and including new elegant forms of conditional expressions and let 
expressions as part of TFX. 
(These more elegant forms have been mirrored in THF, but this is not a topic of
this paper.)
TFX is a superset of the TFF language. 
This paper describes the extensions to the TFF language form that define the 
TFX language.
The remainder of this paper is organized as follows:
Section~\ref{TPTPFOOL} reviews the TFF language, and describes FOOL.
Section~\ref{TFX} provides technical and syntax details of the new features 
of TFX.
Section~\ref{ImplementationExamples} describes the evolving software 
support for TFX, and provides some examples that illustrate its use.
Section~\ref{Conclusion} concludes.

%------------------------------------------------------------------------------
\section{The TFF Language and FOOL}
\label{TPTPFOOL}

The TPTP language is a human-readable, easily machine-parsable, flexible and
extensible language, suitable for writing both ATP problems and solutions.
The top level building blocks of the TPTP language are {\em annotated
formulae}.
An annotated formula has the form:\\
\hspace*{1cm}{\em language}{\tt (}{\em name}{\tt ,}
{\em role}{\tt ,}
{\em formula}{\tt ,}
{\tt [}{\em source}{\tt ,}
{\tt [}{\em useful\_info}{\tt ]]).}\\
The {\em language}s supported are clause normal form ({\tt cnf}),
first-order form ({\tt fof}), typed first-order form ({\tt tff}), and
typed higher-order form ({\tt thf}).
The {\em role}, e.g., {\tt axiom}, {\tt lemma}, {\tt conjecture},
defines the use of the formula in an ATP system.
In the {\em formula}, terms and atoms follow Prolog conventions, i.e.,
functions and predicates start with a lowercase letter or are {\tt '}single
quoted{\tt '}, variables start with an uppercase letter, and all
contain only alphanumeric characters and underscore.
The TPTP language also supports interpreted symbols, which either start with a
{\tt \$}, or are composed of non-alphanumeric characters, e.g., the truth
constants {\tt \$true} and {\tt \$false}, and integer/rational/real
numbers such as 27, 43/92, -99.66.
The basic logical connectives are
{\tt !}, {\tt ?}, {\tt \verb|~|}, {\tt |}, {\tt \&}, {\tt =>}, {\tt <=},
{\tt <=>}, and {\tt <\verb|~|>},
for
$\forall$, $\exists$, $\neg$, $\vee$, $\wedge$, $\Rightarrow$, $\Leftarrow$,
$\Leftrightarrow$, and $\oplus$ respectively.
Equality and inequality are expressed as the infix operators {\tt =} and
{\tt !=}.
An example annotated first-order formula, supplied from a file, is:
\[
\begin{minipage}{\textwidth}
\begin{verbatim}
    fof(union,axiom,
        ( ! [X,A,B] :
            ( member(X,union(A,B))
          <=> ( member(X,A)
              | member(X,B) ) )
        file('SET006+0.ax',union),
        [description('Definition of union'), relevance(0.9)]).
\end{verbatim}
\end{minipage}
\]

%------------------------------------------------------------------------------
\subsection{The Typed First-order Form TFF}
\label{TFF}

TFF extends the basic FOF language with {\em types} and {\em type
declarations}.
The TF0 variant is monomorphic, and the TF1 variant is rank-1 polymorphic.
Every function and predicate symbol is declared before its use, with
a {\em type signature} that specifies the types of the symbol's arguments
and result.
TF0 types $\tau$ have the following forms:
\begin{itemize}
\item the predefined types {\tt \$i} for $\iota$ (individuals) and
      {\tt \$o} for $o$ (booleans);
\item the predefined arithmetic types {\tt \$int} (integers), {\tt \$rat}
      (rationals), and {\tt \$real} (reals);
\item user-defined types (constants).
\end{itemize}
User-defined types are declared (before their use) to be of the kind
{\tt \$tType}, in annotated formulae with a {\tt type} role -- see
Figure~\ref{TF0Example} for examples.
% All symbols share the same namespace; in particular, a type cannot have the
% same name as a function or predicate symbol.
TF0 type signatures $\varsigma$ have the following forms:
\begin{itemize}
\item individual types $\tau$;
\item {\tt ($\tau_1\;$*$\;{\cdots}\;$*$\;\tau_n$)$\;$>$\;\tilde \tau$}
      for $n > 0$, where $\tau_i$ are the argument types, and $\tilde \tau$
      is the result type.
      % Argument types and the result type for a function cannot be
      % {\tt \$o}, and the result type for a predicate must be {\tt \$o}.
      % If $n = 1$ the parentheses are omitted.
\end{itemize}
The type signatures of uninterpreted symbols are declared like types, in
annotated formulae with a {\tt type} role -- see Figure~\ref{TF0Example}
for examples.
The type of {\tt =} is ad hoc polymorphic over all types except {\tt \$o} (this
restriction is lifted in TFX), with both arguments having the same type and 
the result type being {\tt \$o}.
The types of arithmetic predicates and functions are ad hoc polymorphic
over the arithmetic types; see \cite{SS+12} for details.
Figure~\ref{TF0Example} illustrates some TF0 formulae, whose conjecture can
be proved from the axioms (it is the TPTP problem {\tt PUZ130\_1.p}).

\begin{figure}[htbp]
\begin{small}
\begin{verbatim}
%------------------------------------------------------------------------------
tff(animal_type,type, animal: $tType ).
tff(cat_type,type, cat: $tType ).
tff(dog_type,type, dog: $tType ).
tff(human_type,type, human: $tType ).
tff(cat_to_animal_type,type, cat_to_animal: cat > animal ).
tff(dog_to_animal_type,type, dog_to_animal: dog > animal ).
tff(garfield_type,type, garfield: cat ).
tff(odie_type,type, odie: dog ).
tff(jon_type,type, jon: human ).
tff(owner_of_type,type, owner_of: animal > human ).
tff(chased_type,type, chased: ( dog * cat ) > $o ).
tff(hates_type,type, hates: ( human * human ) > $o ).

tff(human_owner,axiom, ! [A: animal] : ? [H: human] : H = owner_of(A) ).
tff(jon_owns_garfield,axiom, jon = owner_of(cat_to_animal(garfield)) ).
tff(jon_owns_odie,axiom, jon = owner_of(dog_to_animal(odie)) ).
tff(jon_owns_only,axiom,
    ! [A: animal] :
      ( jon = owner_of(A)
     => ( A = cat_to_animal(garfield) | A = dog_to_animal(odie) ) ) ).

tff(dog_chase_cat,axiom,
    ! [C: cat,D: dog] :
      ( chased(D,C)
     => hates(owner_of(cat_to_animal(C)),owner_of(dog_to_animal(D))) ) ).
tff(odie_chased_garfield,axiom, chased(odie,garfield) ).

tff(jon_hates_jon,conjecture, hates(jon,jon) ).
%------------------------------------------------------------------------------
\end{verbatim}
\end{small}
\caption{TF0 Formulae}
\label{TF0Example}
\end{figure}

The polymorphic TF1 extends TF0 with (user-defined) {\em type constructors}, 
{\em type variables}, polymorphic symbols, and one new binder.
TF1 types $\tau$ have the following forms:
\begin{itemize}
\item the predefined types {\tt \$i} and {\tt \$o};
\item the predefined arithmetic types {\tt \$int}, {\tt \$rat}, and 
      {\tt \$real};
\item user-defined $n$-ary type constructors applied to $n$ type arguments;
\item type variables, which must be quantified by {\tt !>} -- see the type
      signature forms below.
\end{itemize}
Type constructors are declared (before their use) to be of the kind
{\tt (\$tType$\;$*$\;{\cdots}\;$*$\;$\$tType)$\;$> \$tType}, in annotated 
formulae with a {\tt type} role.
% The type constructor's arity is the number of ``{\tt \$tType}''s before
% the {\tt >}.
% If the arity is zero the {\tt >} is omitted, and the type constructor is
% a monomorphic user-defined type constant as in TF0, else it is polymorphic.
% If the arity is less than two the parentheses are omitted.
% In the example of Figure~\ref{TF1Example}, {\tt cup\_of} is a unary type
% constructor that is is used to construct the type {\tt cup\_of(beverage))}.
TF1 type signatures $\varsigma$ have the following forms:
\begin{itemize}
\item individual types $\tau$;
\item {\tt ($\tau_1\;$*$\;{\cdots}\;$*$\;\tau_n$)$\;$>$\;\tilde \tau$}
      for $n > 0$, where $\tau_i$ are the argument types and $\tilde \tau$
      is the result type (with the same caveats as for TF0);
\item {\tt !>[$\alpha_1$:$\;$\$tType,$\;{\dots}\;$,$\alpha_n$:$\;$\$tType]:$\;\varsigma$}
      for $n > 0$, where $\alpha_1,\dots,\alpha_n$ are distinct
      type variables and $\varsigma$ is a type signature.
\end{itemize}
The {\tt !>} binder in the last form denotes universal quantification in the
style of $\lambda\Pi$ calculi.
It is only used at the top level in polymorphic type signatures.
All type variables must be of type {\tt \$tType}; more complex type variables,
e.g., {\tt \$tType$\;$>$\;$\$tType} are beyond rank-1 polymorphism.
% In the example of Figure~\ref{TF1Example}, the type signature for 
% {\tt mixture} is polymorphic.
As in TF0, arithmetic symbols and equality are ad hoc polymorphic.
An example of TF1 formulae can be found in \cite{KSR16}.
% Figure~\ref{TF1Example} illustrates some TF1 formulae, whose conjecture can
% be proved from the axioms (it is a variant of the TPTP problem 
% {\tt PUZ139\_1.p}).
% 
% \begin{figure}[htbp]
% \begin{small}
% \begin{verbatim}
% %------------------------------------------------------------------------------
% tff(beverage_type,type,( beverage: $tType )).
% tff(syrup_type,type,( syrup: $tType )).
% tff(cup_of_type,type,( cup_of: $tType > $tType )).
% tff(full_cup_type,type,( full_cup: beverage > cup_of(beverage) )).
% tff(coffee_type,type,( coffee: beverage )).
% tff(vanilla_type,type,( vanilla: syrup )).
% tff(caramel_type,type,( caramel: syrup )).
% tff(help_stay_awake_type,type,( help_stay_awake: cup_of(beverage) > $o )).
% 
% tff(mixture_type,type,(
%     mixture: !>[BeverageOrSyrup: $tType] :
%                ( ( BeverageOrSyrup * syrup ) > BeverageOrSyrup ) )).
% 
% %----Coffee keeps you awake
% tff(mixture_of_coffee_help_stay_awake,axiom,(
%     ! [S: syrup] : help_stay_awake(full_cup(mixture(beverage,coffee,S))) )).
% 
% %----Coffee mixed with a syrup or two helps you stay awake
% tff(syrup_coffee_help_stay_awake,conjecture,(
%     help_stay_awake(full_cup(
%       mixture(beverage,coffee,mixture(syrup,caramel,vanilla)))) )).
% %------------------------------------------------------------------------------
% \end{verbatim}
% \end{small}
% \caption{TF1 Formulae}
% \label{TF1Example}
% \end{figure}

%------------------------------------------------------------------------------
% \subsection{The Typed Higher-order Form THF}
% \label{THF}
% 
% THF extends FOF with higher-order notions, including adoption of curried 
% form for type declarations, lambda terms (with a lambda binder), symbol 
% application, and new binders.
% The TH0 variant is monomorphic, and the TH1 variant is rank-1 polymorphic.
% TH0 types $\tau$ have the following forms:
% \begin{itemize}
% \item the predefined types {\tt \$i} and {\tt \$o};
% \item the predefined arithmetic types {\tt \$int}, {\tt \$rat}, and 
%       {\tt \$real};
% \item user-defined types (constants);
% \item {\tt ($\tau_1\;$>$\;{\cdots}\;$>$\;\tau_n\;$>$\;\tilde \tau$)}
%       for $n > 0$, where $\tau_i$ are the argument types and $\tilde \tau$
%       is the result type.
% \end{itemize}
% TH0 type signatures $\varsigma$ have the following forms:
% \begin{itemize}
% \item individual types $\tau$.
% \end{itemize}
% The {\tt ($\tau_1\;$>$\;{\cdots}\;$>$\;\tau_n\;$>$\;\tilde \tau$)}
% form is promoted to be a type in TH0 (and TH1) forms, so that variables in
% formulae can be quantified as function types.
% The curried form means that TH0 provides the possibility of partial
% application.
% As in TF0, arithmetic symbols and equality are ad hoc polymorphic.
% The new binary connective {\tt @} represents application.
% % (explicit use of
% % {\tt @} is required -- symbols cannot simply be juxtaposed) -- see
% % Figure~\ref{TH0Example} for examples.
% There are three new binders: {\tt \verb|^|}, {\tt @+}, and {\tt @-}, for
% $\lambda$, $\epsilon$ (indefinite description, aka choice), and $\iota$
% (definite description).
% Use of all the connectives as terms is also supported.
% %  -- this is quite
% % straightforward because connectives are equivalent (in Henkin semantics -
% % see below) to corresponding lambda abstractions.
% % The arithmetic predicates and functions, and the equality operator, can also
% % be used as terms, but must be applied to a term of a known type (which must
% % be an arithmetic type for the arithmetic symbols).
% The semantics for TH0 is Henkin semantics with choice (Henkin semantics
% by definition also includes Boolean and functional extensionality)
% \cite{BBK04,Hen50}.
% Figure~\ref{TH0Example} illustrates some TH0 formulae, whose conjecture can
% be proved from the axioms (it is a variant of the TPTP problem
% {\tt PUZ140\verb|^|1.p}).
% 
% \begin{figure}[htbp]
% \begin{small}
% \begin{verbatim}
% %------------------------------------------------------------------------------
% thf(syrup_type,type,( syrup: $tType )).
% thf(beverage_type,type,( beverage: $tType )).
% thf(coffee_type,type,( coffee: beverage )).
% thf(mix_type,type,( mix: beverage > syrup > beverage )).
% thf(coffee_mixture_type,type,( coffee_mixture: syrup > beverage )).
% thf(hot_type,type,( hot: beverage > $o )).
% 
% %----The mixture of coffee and something
% thf(coffee_mixture_definition,definition,
%     ( coffee_mixture = ( mix @ coffee ) )).
% 
% %----Any coffee mixture is hot coffee
% thf(coffee_and_syrup_is_hot_coffee,axiom,(
%     ! [S: syrup] : ( ( (coffee_mixture @ S) = coffee )
%                    & ( hot @ ( coffee_mixture @ S ) )) )).
% 
% %----There is some mixture of coffee and any syrup which is hot coffee
% thf(there_is_hot_coffee,conjecture,(
%     ? [SyrupMixer: syrup > beverage] :
%     ! [S: syrup] :
%     ? [B: beverage] :
%       ( ( B = ( SyrupMixer @ S ) ) & ( B = coffee ) & ( hot @ B ) ) )).
% %------------------------------------------------------------------------------
% \end{verbatim}
% \end{small}
% \caption{TH0 Formulae}
% \label{TH0Example}
% \end{figure}
% 
% 
% The polymorphic TH1 combines the higher-order features of TH0 
% with the polymorphic features of TF1.
% TH1 also adds five new polymorphic constants.
% TH1 types $\tau$ have the following forms:
% \begin{itemize}
% \item the predefined types {\tt \$i} and {\tt \$o};
% \item user-defined $n$-ary type constructors applied to $n$ type arguments;
% \item type variables (which must be quantified by {\tt !>});
% \item {\tt ($\tau_1\;$>$\;{\cdots}\;$>$\;\tau_n\;$>$\;\tilde \tau$)}
%       for $n > 0$, where $\tau_i$ are the argument types and $\tilde \tau$
%       is the result type.
% \end{itemize}
% TH1 type signatures $\varsigma$ have the following forms:
% \begin{itemize}
% \item individual types;
% \item {\tt !>[$\alpha_1$:$\;$\$tType,$\;{\dots}\;$,$\alpha_n$:$\;$\$tType]:$\;\varsigma$}
% \ for $n > 0$, where $\alpha_1,\dots,\alpha_n$ are distinct
% type variables and $\varsigma$ is a type signature.
% \end{itemize}
% TH1 has five new polymorphic constants:
% {\tt !!} for $\Pi$ (universal quantification),
% {\tt ??} for $\Sigma$ (existential quantification),
% {\tt @@+} for $\epsilon$ (indefinite description, aka choice),
% {\tt @@-} for $\iota$ (definite description), 
% and  
% {\tt @=} (equality).
% % \footnote{%
% % {\tt !!} and {\tt ??} used to be in TH0, but they have been moved out to
% % be in only TH1 now.}
% Each of these must be instantiated by applying them to exactly one type 
% argument.
% % e.g.,\\
% %\hspace*{1cm}{\tt ?$\;$[B:$\;$bird]$\;$:$\;$($\;$(@=$\;$@$\;$bird)$\;$@$\;$tweety$\;$@$\;$B$\;$)}.
% An example of TH1 formulae can been found in \cite{KSR16}.
% % Figure~\ref{TH1Example} illustrates some TH1 formulae, whose conjecture can
% % be proved from the axioms.
% % It declares and axiomatizes {\tt lookup} and {\tt update} operations on
% % maps, then conjectures that {\tt update} is idempotent for certain keys and
% % values.
% % 
% % \begin{figure}[htbp]
% % \begin{small}
% % \begin{verbatim}
% % %------------------------------------------------------------------------------
% % thf(bird_type,type,( bird: $tType )).
% % thf(tweety_type,type,( tweety: bird )).
% % 
% % thf(list_type,type,( list: $tType > $tType )).
% % thf(map_type,type,( map: $tType > $tType > $tType )).
% % 
% % thf(bird_lookup_type,type,(
% %     bird_lookup: !>[A: $tType,B: $tType] : ( ( map @ A @ B ) > A > B ) )).
% % thf(bird_update_type,type,(
% %     bird_update: !>[A: $tType,B: $tType] :
% %                    ( ( map @ A @ B ) > A > B > ( map @ A @ B ) ) )).
% % thf(idempotent_type,type,( idempotent: !>[A: $tType] : ( ( A > A ) > $o ) )).
% % 
% % thf(bird_lookup_update_same,axiom,(
% %     ! [RangeType: $tType,Map: ( map @ bird @ RangeType ),
% %        Key: bird,Value: RangeType] :
% %       ( ( bird_lookup @ bird @ RangeType @
% %           ( bird_update @ bird @ RangeType @ Map @ Key @ Value ) @ Key )
% %       = Value ) )).
% % 
% % thf(idempotent_def,definition,(
% %     ! [A: $tType,F: ( A > A )] :
% %       ( ( idempotent @ A @ F )
% %       = ( ! [X: A] : ( ( F @ ( F @ X ) ) = ( F @ X ) ) ) ) )).
% % 
% % thf(higher_order_conjecture,conjecture,(
% %     ! [Value: ( list @ $i )] :
% %       ( idempotent @ ( map @ bird @ ( list @ $i ) )
% %       @ ^ [Map: ( map @ bird @ ( list @ $i ) )] :
% %           ( bird_update @ bird @ ( list @ $i ) @ Map @ tweety @ Value ) ) )).
% % %------------------------------------------------------------------------------
% % \end{verbatim}
% % \end{small}
% % \caption{TH1 Formulae}
% % \label{TH1Example}
% % \end{figure}

%------------------------------------------------------------------------------
\subsection{FOOL}
\label{FOOL}
FOOL \cite{KKV15}, standing for First-Order Logic (FOL) + bOoleans, is a 
variation of many-sorted first-order logic. FOOL extends the ordinary FOL in
that it (i)~contains an interpreted boolean sort and allows formulae to be used
as boolean terms, (ii)~allows boolean variables to be used as formulae,
(iii)~contains conditional expressions, and (iv)~contains let expressions with
definitions of function symbols, predicate symbols, and tuples. 
FOOL can be straightforwardly extended with the polymorphic theory of 
tuples \cite{KKV18}, and in what follows we consider that extension. 
This theory includes first class tuples type and first class tuple terms. 
First class tuple terms and tuple types are part of TFX as well. 
There is a model-preserving transformation of FOOL formulae to FOL formulae
\cite{KKV15}, so that an implementation of the transformation makes it 
possible to reason about FOOL formulae using a regular first-order theorem 
prover. 
Formulae of FOOL can also be efficiently translated to a first-order clausal 
normal form~\cite{KK+16-GCAI}. 
The following describes these features of FOOL, illustrating them using 
examples taken from \cite{KK+16} and \cite{KKV18}.

\subsubsection*{Boolean terms}
FOOL contains a fixed two-element type $\bool$, allows quantification over 
variables of the type $\bool$, and considers terms of the type $\bool$ to be
formulae. Formula~\ref{eq:fool-bool-var} is a syntactically correct tautology
in FOOL.
\begin{equation}\label{eq:fool-bool-var}
(\forall x:\bool)(x \lor \neg x)
\end{equation}
The existence of $\bool$ terms means that a function or a predicate can take 
a formula as an argument, and formulae can be used as arguments to equality.
For example, logical implication can be defined as a binary function
$\mathit{impl}$ of the type $\bool \times \bool \to \bool$ using the following
axiom.
\begin{equation}\label{eq:fool-impl}
(\forall x:\bool)(\forall y:\bool)(\mathit{impl}(x,y) \liff \neg x \lor y).
\end{equation}
Formula \ref{eq:fool-impl} can be equivalently expressed with $=$ instead of
$\liff$.
Then it is possible to express that $P$ is a graph of a (partial) function of 
the type $\sigma \to \tau$ as follows.
\begin{equation}\label{eq:bool-arg-example}
(\forall x:\sigma)(\forall y:\tau)(\forall z:\tau)
\mathit{impl}(P(x,y) \land P(x,z), y = z)
\end{equation}

\subsubsection*{Tuples}
FOOL extended with the theory of tuples contains a type
$\tuple{\sigma_1,\ldots,\sigma_n}$ of the $n$-ary tuple for all types
$\sigma_1,\ldots,\sigma_n$, $n>0$. Each type
$\tuple{\sigma_1,\ldots,\sigma_n}$ is first class, that is, it can be
used in the type of a function or predicate symbol and in a
quantifier. An expression $\tuple{t_1,\ldots,t_n}$, where $t_1,\ldots,t_n$ are
terms of types $\sigma_1,\ldots,\sigma_n$, respectively, is a term of the type
$\tuple{\sigma_1,\ldots,\sigma_n}$. Each tuple term is first class and can be used as an argument to a function symbol, a predicate symbol, or equality.

Tuples are ubiquitous in mathematics and programming languages. For example,
one can use the tuple sort $\tuple{\mathds{R},\mathds{R}}$ as the sort of
complex numbers. Thus, the term $\tuple{2,3}$ represents the complex number
$2+3i$. A function symbol $\mathit{plus}$ which represents addition of complex numbers has the type $\tuple{\mathds{R},\mathds{R}} \times \tuple{\mathds{R},\mathds{R}} \to \tuple{\mathds{R},\mathds{R}}$.

\subsubsection*{Conditional expressions}
FOOL contains expressions of the form $\ite{\psi}{s}{t}$, where $\psi$ is a
formula, and $s$ and $t$ are terms of the same type. 
The semantics of such expressions mirrors the semantics of conditional 
expressions in programming languages, and are therefore convenient for 
expressing formulae coming from program analysis. 
For example, consider the $\mathit{max}$ function of the type 
$\mathds{Z}\times\mathds{Z}\to\mathds{Z}$ that returns the maximum of its 
arguments. 
Its definition can be expressed in FOOL as
\begin{equation}\label{eq:ite-t-example}
(\forall x:\mathds{Z})(\forall y:\mathds{Z})
(\mathit{max}(x, y) = \ite{x \geq y}{x}{y}).
\end{equation}

FOOL allows if-then-else expressions to occur as formulae, as in the
following valid property of $\mathit{max}$
\begin{equation}\label{eq:ite-f-example}
(\forall x:\mathds{Z})(\forall y:\mathds{Z})
(\ite{\mathit{max}(x, y) = x}{x \geq y}{y \geq x}).
\end{equation}

\subsubsection*{Let expressions}
FOOL contains expressions of the form $\letindef{D_1;\ldots;D_k}{t}$, where
$k > 0$, $t$ is either a term or a formula, and $D_1,\ldots,D_k$ are
simultaneous non-recursive definitions. FOOL allows definitions of function
symbols, predicate symbols, and tuples.

The definition of a function symbol 
$f:\sigma_1\times\ldots\times\sigma_n\to\tau$ has the form 
$\binding{f(x_1:\sigma_1,\ldots,x_n:\sigma_n)}{s}$, where
$n \geq 0$, and $s$ is a term of the type $\tau$.
The following let expression denotes the maximum of three integer constants
$a$, $b$, and $c$ using a local definition of the function symbol
$\mathit{max}$.
\begin{equation}\label{eq:fool-let-impl}
\begin{aligned}
\mathtt{let}\;&\binding{\mathit{max}(x:\mathds{Z},y:\mathds{Z})}
                       {\ite{x \geq y}{x}{y}}\\
 \mathtt{in}\;&\mathit{max}(\mathit{max}(a,b),c)
\end{aligned}
\end{equation}

The definition of a predicate symbol $p:\sigma_1\times\ldots\times\sigma_n$ has 
the form $\binding{p(x_1:\sigma_1,\ldots,x_n:\sigma_n)}{\phi}$, where 
$n \geq 0$, and $\phi$ is a formula.
The following let expression denotes equivalence of two boolean constants 
$A$ and $B$ using a local definition of the predicate symbol $\mathit{impl}$.
\begin{equation}\label{eq:fool-let-impl}
\begin{aligned}
\mathtt{let}\;&\binding{\mathit{impl}(x:\bool,y:\bool)}{\neg x \lor y}\\
 \mathtt{in}\;&\mathit{impl}(A,B)\wedge\mathit{impl}(B,A)
\end{aligned}
\end{equation}

The definition of a tuple has the form $\binding{(c_1,\ldots,c_n)}{s}$, where
$n > 1$, $c_1,\ldots,c_n$ are constant symbols of the types
$\sigma_1,\ldots,\sigma_n$, respectively, and $s$ is a term of the type
$(\sigma_1,\ldots,\sigma_n)$. The following formula defines addition for
complex numbers using two simultaneous local definition of tuples.
\begin{equation}\label{eq:fool-tuple-let}
  \begin{aligned}
  &(\forall x:(\mathds{R},\mathds{R}))(\forall y:(\mathds{R},\mathds{R}))\\
  &\quad(\mathit{plus}(x,y) = \letinpar{(a,b)}{x}{(c,d)}{y}{\tuple{a+c,b+d}).}
  \end{aligned}
\end{equation}

The main application of let expressions with tuple definitions is in 
problems coming from program analysis, namely modelling of assignments
\cite{KKV18}.
The lefthand side of Figure~\ref{fig:simple-if} shows an example of an 
imperative \texttt{if} statement containing assignments to integer variables, 
and an \texttt{assert} statement. 
This can be encoded as a FOOL formula as shown on the righthand side, using 
let expressions with definitions of tuples that capture the assignments.

\begin{figure}[htbp]
\begin{center}
\begin{tabular}[t]{ll}
\begin{minipage}{0.3\textwidth}
\begin{verbatim}
if (x > y) {
   t := x;
   x := y;
   y := t;
}
assert x <= y;
\end{verbatim}
\end{minipage}
&
\begin{minipage}{0.3\textwidth}
\[
  \letnl{(x,y,t)}{\itenll{x > y}
                 {\letinnl{t}{x}
                          {\letinnl{x}{y}
                                   {\letinnl{y}{t}
                                            {(x,y,t)}}}}
                 {(x,y,t)}}
        {x \le y}
\]
\end{minipage}
\\
\end{tabular}
\end{center}
\caption{FOOL encoding of an {\tt if} statement}
\label{fig:simple-if}
\end{figure}

The semantics of let expressions in FOOL mirrors the semantics of
simultaneous non-recursive local definitions in programming languages. That is,
neither of the definitions $D_1,\ldots,\allowbreak D_n$ uses function or
predicate symbols created by any other definition. In the following example,
constants $a$ and $b$ are swapped by a let expression. The resulting formula
is equivalent to $f(b, a)$.
\begin{equation}\label{eq:parallel-let-example}
\mathtt{let}\;\binding{a}{b}\,;\,\binding{b}{a}\;\mathtt{in}\;f(a, b)
\end{equation}

%------------------------------------------------------------------------------
\section{The TFX Syntax}
\label{TFX}

The TPTP syntax has been extended to provide the features of FOOL,
and at the same time some of the previous weaknesses have been remedied.
Formulae and term have been conflated (with some exceptions).
Tuples have been simplified in TFF, and fully expressive tuples included in 
TFX. 
The old conditional expressions and let expressions from TFF have been 
removed, and new elegant forms have been included as part of TFX. 
The grammar of THX is captured in version v7.1.0.2 of the TPTP syntax,
available online at \url{http://www.tptp.org/TPTP/SyntaxBNF.html}.
In the subsections below, the relevant excerpts of the BNF are provided,
with examples and commentary.

%------------------------------------------------------------------------------
\subsection{Boolean variables as formulae}

Variables of type {\tt \$o} can be used as formulae. 
The BNF excerpt is~\ldots
\begin{verbatim}
<tff_unitary_formula>  ::= <tff_quantified_formula> | <tff_atomic_formula> |
                           <tfx_unitary_formula> | (<tff_logic_formula>)
<tfx_unitary_formula>  ::= <variable>
\end{verbatim}

For example, Formula~\ref{eq:fool-bool-var} can be written in the TFX syntax as
follows.
\begin{verbatim}
    tff(tautology,conjecture,! [X: $o]: (X | (~X)) ).
\end{verbatim}

The type of the $\mathit{impl}$ predicate can be written in the TFX syntax as
\verb'($o * $o) > $o' and its definition in Formula~\ref{eq:fool-impl} can be
written as follows.
\begin{verbatim}
    tff(impl_type,type,impl: ($o * $o) > $o ).
    tff(impl_defn,axiom, ! [X: $o,Y: $o]: (impl(X,Y) <=> ((~X) | Y)) ).
\end{verbatim}

Notice that the negation of a boolean variable used as a formula must be
placed inside parenthesis.

%------------------------------------------------------------------------------
\subsection{Formulae as boolean terms}

Formulae can be used as boolean terms. 
The BNF excerpt is~\ldots
\begin{verbatim}
<tff_logic_formula>    ::= <tff_unitary_formula> | <tff_unary_formula> |
                           <tff_binary_formula> | <tff_defined_infix>
<tff_term>             ::= <tff_logic_formula> | <defined_term> | <tfx_tuple>
<tff_unitary_term>     ::= <tff_atomic_formula> | <defined_term> |
                           <tfx_tuple> | <variable> | (<tff_logic_formula>)
\end{verbatim}

Formula~\ref{eq:bool-arg-example} can be written in TFX as follows.
\begin{verbatim}
    tff(s,type,s: $tType).
    tff(t,type,t: $tType).
    tff(p,type,p: (s * t) > $o ).
    tff(graph,axiom,
        ! [X: s,Y: t,Z: s] : impl(p(X,Y) & p(X,Z), Y = Z) ).
\end{verbatim}
% For example~\ldots
% \begin{verbatim}
%     tff(p_type,type,p: ($i * $o * $int) > $o ).
%     tff(q_type,type,q: ($int * $i) > $o ).
%     tff(me_type,type,me: $i ).
%     tff(fool_1,axiom,! [X: $int] : p(me,! [Y: $i] : q(X,Y),27) ).
% \end{verbatim}
% \ldots~and~\ldots
% \begin{verbatim}
%     tff(p_type,type,p: $i > $o ).
%     tff(q_type,type,q: $i > $o ).
%     tff(me_type,type,me: $i ).
%     tff(fool_2,axiom,q((~p(me)) != q(me)) ).
% \end{verbatim}

A consequence of allowing formulae as terms is that the default typing of 
functions and predicates supported in plain TFF (functions default to 
{\tt (\$i * \ldots * \$i) > \$i} and predicates default to 
{\tt (\$i * \ldots * \$i) > \$o)} is not supported in TFX (as is the case 
for THF).

Note that not all terms can be used as formulae.
Tuples, numbers, and ``distinct objects'' cannot be used as formulae.

%------------------------------------------------------------------------------
\subsection{Tuples}

Tuples in TFF are written in {\tt []} brackets, and can contain only
non-boolean terms -- tuples of formulae have been removed from TFF. 
Tuples in TFX are written in {\tt []} brackets, and can contain any type of 
term (including formulae and variables of type {\tt \$o}). 
Signatures can contain tuple types. 
The BNF excerpt is~\ldots
\begin{verbatim}
<tfx_tuple_type>       ::= [<tff_type_list>]
<tff_type_list>        ::= <tff_top_level_type> |
                           <tff_top_level_type>,<tff_type_list>

<tfx_tuple>            ::= [] | [<tff_arguments>]
<tff_arguments>        ::= <tff_term> | <tff_term>,<tff_arguments>
\end{verbatim}

The tuple type $\tuple{\mathds{R},\mathds{R}}$ can be written in the TFX syntax as \verb|[$real,$real]| and the type of the addition function for complex numbers $\tuple{\mathds{R},\mathds{R}} \times \tuple{\mathds{R},\mathds{R}} \to \tuple{\mathds{R},\mathds{R}}$ can be written as
\verb'([$real,$real] * [$real,$real]) > [$real,$real]'. The tuple term $\tuple{2,3}$ can be written as \verb'[2,3]'.

% For example~\ldots
% \begin{verbatim}
%     tff(t1_type,type,t1: $tType ).
%     tff(d_type,type,d: [$i,t1,$int] ).
%     tff(p_type,type,p: [t1,$i] > $o ).
%     tff(f_type,type,f: ($o * [$i,t1,$int]) > [t1,$i] ).
%     tff(tuples_2,axiom,p(f($true,d)) ).
% \end{verbatim}
Tuples can occur only as terms (not as formulae, and not on the lefthand side 
of a type declaration), anywhere they are well-typed. 
For example~\ldots
\begin{verbatim}
    tff(p_type,type,p: ([$int,$i,$o] * $o * $int) > $o ).
    tff(q_type,type,q: ($int * $i) > $o ).
    tff(me_type,type,me: $i ).
    tff(tuples_1,axiom,! [X: $int] : p([33,me,$true],! [Y: $i] : q(X,Y),27) ).
\end{verbatim}
Tuples cannot be typed. Rather the elements must be typed separately. 
For example~\ldots
\begin{verbatim}
    tff(a_type,type,a: $int).
    tff(b_type,type,b: $int).
\end{verbatim}
\ldots~cannot be abbreviated to~\ldots
\begin{verbatim}
    tff(ab_type,type,[a,b]: [$int,$int]).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Conditional expressions}

Conditional expressions are parametric polymorphic, taking a formula as the 
first argument, then two formulae or terms of the same type as the second and 
third arguments. The type of the conditional expression is the type of its second and third arguments. The BNF excerpt is~\ldots
\begin{verbatim}
<tfx_conditional>      ::= $ite(<tff_logic_formula>,<tff_term>,<tff_term>)
\end{verbatim}

Formulas~\ref{eq:ite-t-example} and \ref{eq:ite-f-example} can be expressed in
TFX as follows.
\begin{verbatim}
    tff(max_type,type,max: ($int * $int) > $int).
    tff(max_defn,axiom,
        ! [X: $int,Y: $int]: max(X,Y) = $ite($greatereq(X,Y),X,Y) ).
    tff(max_property,conjecture,
        ! [X: $int,Y: $int]: 
          $ite(max(X,Y) = X,$greatereq(X,Y),$greatereq(Y,X)) ).
\end{verbatim}

We use the keyword \verb'$ite' for conditional expressions occurring both as
terms and formulas. This is different from the old TFF syntax of if-then-else
that contained two separate keywords \verb'$ite_t' and \verb'$ite_f'.

Tuples can be used usefully in conditional expressions. For example~\ldots
\begin{verbatim}
    tff(p_type,type,p: [$int,$int] > $o).
    tff(d_type,type,d: [$int,$int]).
    tff(ite_3,axiom,
        ! [X:$int,Y:$int] : p($ite($greater(X,Y),[X,Y],[Y,X])) ).
    tff(ite_4,axiom,
        ! [X:$int,Y:$int] : d = $ite($greater(X,Y),[X,Y],[Y,X]) ).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Let expressions}

Let expressions provide the types of defined symbols, definitions for the 
symbols, and a formula/term in which the definitions are applied. 
Each type declaration is the same as a type declaration in an annotated 
formula with the type role.
Each definition defines the expansion of one of the declared symbols.
The BNF excerpt is~\ldots
\begin{verbatim}
<tfx_let>              ::= $let(<tfx_let_types>,<tfx_let_defns>,<tff_term>)
<tfx_let_types>        ::= <tff_atom_typing> | [<tff_atom_typing_list>]
<tff_atom_typing_list> ::= <tff_atom_typing> |
                           <tff_atom_typing>,<tff_atom_typing_list>
<tfx_let_defns>        ::= <tfx_let_defn> | [<tfx_let_defn_list>]
<tfx_let_defn>         ::= <tfx_let_LHS> <assignment> <tff_term>
<tfx_let_LHS>          ::= <tff_plain_atomic> | <tfx_tuple>
<tfx_let_defn_list>    ::= <tfx_let_defn> | <tfx_let_defn>,<tfx_let_defn_list>
\end{verbatim}
For example~\ldots
\begin{verbatim}
    tff(p_type,type,p: $int > $o ).
    tff(let_1,axiom,$let(c: $int,c:= 27,p(c)) ).
\end{verbatim}
\ldots~is equivalent to~\ldots
\begin{verbatim}
    tff(p_type,type,p: $int > $o ).
    tff(let_1,axiom,p(27) ).
\end{verbatim}
If variables are used in the lefthand side of a definition, their values are 
supplied in the defined symbol's use. 
Such variables do not need to be declared (they are implicitly declared to be 
of the type defined by the symbol declaration), but must be top-level arguments 
of the defined symbol and be pairwise distinct. 
For example~\ldots
\begin{verbatim}
    tff(i_type,type,i: $int).
    tff(j_type,type,j: $int).
    tff(f_type,type,f: ($int * $int * $int * $int) > $rat).
    tff(p_type,type,p: $rat > $o ).
    tff(let_2,axiom,
        $let(ff: ($int * $int) > $rat, ff(X,Y):= f(X,X,Y,Y), p(ff(i,j))) ).
\end{verbatim}
\ldots~is equivalent to~\ldots
\begin{verbatim}
    tff(i_type,type,i: $int).
    tff(j_type,type,j: $int).
    tff(f_type,type,f: ($int * $int * $int * $int) > $rat).
    tff(p_type,type,p: $rat > $o ).
    tff(let_2,axiom,p(f(i,i,j,j)) ).
\end{verbatim}
The defined symbols have scope over the formula/term in which the definitions 
are applied, shadowing any definition outside the let expression. 
The RHS of a definition can have symbols with the same name as the defined 
symbol, but refer to symbols defined outside the let expression. 
For example~\ldots
\begin{verbatim}
    tff(array_type,type,array: $int > $real).
    tff(p_type,type,p: $real > $o).
    tff(let_3,axiom,
        $let(array: $int > $real,
          array(I):= $ite(I = 3,5.2,array(I)),
          p($sum(array(2),array(3))) ) ).
\end{verbatim}
\ldots~is equivalent to~\ldots
\begin{verbatim}
    tff(array_type,type,array: $int > $real).
    tff(p_type,type,p: $real > $o).
    tff(let_3,axiom,p($sum(array(2),5.2)) ).
\end{verbatim}
The occurrence of array in the lefthand side of the definition 
{\tt array(I):=}, and the occurrences in the formula in which the let 
expression is applied {\tt p(\$sum(array(2),array(3)))}, are the defined 
symbol. 
The occurrence in the righthand side of the definition 
{\tt \$ite(I = 3,5,array(I))} is the globally defined symbol.

Tuples can be used to define multiple symbols in let expressions in parallel 
(not sequential, i.e., this is let, not let*). 
Multiple type declarations are given in {\tt []}ed tuples of declarations, and 
multiple definitions are given in {\tt []}ed tuples of definitions. 
For example~\ldots
\begin{verbatim}
    tff(a_type,type,a: $int).
    tff(b_type,type,b: $int).
    tff(p_type,type,p: ($int * $int) > $o).
    tff(let_tuple_1,axiom,$let([a: $int,b: $int],[a:= b,b:= a],p(a,b)) ).
\end{verbatim}
\ldots~is equivalent to~\ldots
\begin{verbatim}
    tff(a_type,type,a: $int).
    tff(b_type,type,b: $int).
    tff(p_type,type,p: ($int * $int) > $o).
    tff(let_tuple_1,axiom,p(b,a)).
\end{verbatim}
\ldots~and~\ldots
\begin{verbatim}
    tff(i_type,type,i: $int).
    tff(f_type,type,f: ($int * $int * $int * $int) > $int).
    tff(p_type,type,p: $int > $o ).
    tff(let_tuple_2,axiom,
        $let([ff: ($int * $int) > $int, gg: $int > $int],
             [ff(X,Y):= f(X,X,Y,Y), gg(Z):= f(Z,Z,Z,Z)],
             p(ff(i,gg(i)))) ).
\end{verbatim}
\ldots~is equivalent to~\ldots
\begin{verbatim}
    tff(i_type,type,i: $int).
    tff(f_type,type,f: ($int * $int * $int * $int) > $int).
    tff(p_type,type,p: $int > $o ).
    tff(let_tuple_2,axiom,p(f(i,i,f(i,i,i,i),f(i,i,i,i))) ).
\end{verbatim}
As tuples cannot be typed~\ldots
\begin{verbatim}
    tff(p_type,type,p: ($int * $int) > $o).
    tff(not_let_tuple,axiom,
        $let([a: $int,b: $int],[a:= b,b:= a],p(a,b)) ).
\end{verbatim}
\ldots~cannot be abbreviated to~\ldots
\begin{verbatim}
    tff(p_type,type,p: ($int * $int) > $o).
    tff(not_let_tuple,axiom,
        $let([a,b]: [$int,$int],[a:= b,b:= a],p(a,b)) ).
\end{verbatim}
Sequential let expressions (let*) can be implemented by nesting. 
For example~\ldots
\begin{verbatim}
    tff(i_type,type,i: $int).
    tff(f_type,type,f: ($int * $int * $int * $int) > $int).
    tff(p_type,type,p: $int > $o ).
    tff(let_tuple_3,axiom,
        $let(ff: ($int * $int) > $int,
             ff(X,Y):= f(X,X,Y,Y),
             $let(gg: $int > $int,gg(Z):= ff(Z,Z),p(gg(i)) ) ) ).
\end{verbatim}
\ldots~is equivalent to~\ldots
\begin{verbatim}
    tff(i_type,type,i: $int).
    tff(f_type,type,f: ($int * $int * $int * $int) > $int).
    tff(p_type,type,p: $int > $o ).
    tff(let_tuple_3,axiom,p(f(i,i,i,i)) ).
\end{verbatim}
Tuples can be used directly in let expressions. 
For example~\ldots
\begin{verbatim}
    tff(p_type,type,p: ($int * $int) > $o ).
    tff(q_type,type,q: [$int,$int] > $o ).
    tff(let_tuple_4,axiom,$let([a:$int,b:$int], [a,b]:= [27,28], p(a,b)) ).
    tff(let_tuple_5,axiom,$let(d: [$int,$int], d:= [27,28],q(d)) ).
\end{verbatim}
\ldots~is equivalent to~\ldots
\begin{verbatim}
    tff(p_type,type,p: ($int * $int) > $o ).
    tff(q_type,type,q: [$int,$int] > $o ).
    tff(let_tuple_4,axiom,p(27,28)) ).
    tff(let_tuple_5,axiom,q([27,28])) ).
\end{verbatim}
%------------------------------------------------------------------------------
\section{Software Support and Examples}
\label{ImplementationExamples}

%------------------------------------------------------------------------------
\subsection{Software for TFX}
\label{Software}

The BNF provides the automatically generated lex/yacc parsers for TPTP files.
At the time of writing this paper, the TPTP4X utility is being upgraded
to support TFX.

The Vampire theorem prover \cite{KV13} supports all features of FOOL. 
Vampire transforms FOOL formulae into a set of first-order clauses using the 
VCNF algorithm \cite{KK+16-GCAI}, and then reasons with these clauses using 
its usual resolution calculi for first-order logic. 
At the time of writing this paper the latest released version of Vampire,
4.2.2, uses a syntax for FOOL that slightly differs from TFX. 
Full support for the TFX syntax has been implemented in a recent revision of 
the Vampire source code~\footnote{%
\url{https://github.com/vprover/vampire}}, and will be available
in the next release of Vampire.

TFX has been used by two program verification tools BLT~\cite{CF17} and
Voogie~\cite{KKV18}. 
Both BLT and Voogie read programs written in a subset of the Boogie 
intermediate verification language and generate their partial correctness 
properties written in the TFX syntax. 
BLT and Voogie generate formulae differently, but both rely on features of 
FOOL, namely conditional expressions, let expressions, and tuples.

%------------------------------------------------------------------------------
\subsection{Examples}
\label{Examples}

Figure~\ref{ImplicationFunction} shows an example that uses formulae as
terms, quantifies over boolean variables, and uses boolean equality as 
equivalence.

\begin{figure}[htbp]
\begin{small}
\begin{verbatim}
%------------------------------------------------------------------------------
tff(imply,type, imply: ( $o * $o ) > $o ).
tff(graph,type, p: ( $i * $i ) > $o ).

tff(imply_definition,axiom,
    ! [X:$o,Y:$o] : ( imply(X,Y) = ( ~ X | Y) ) ).

tff(graph_impl,axiom,
    ! [X: $i,Y: $i] : ( p(X,Y) => f(X) = Y ) ).

tff(graph_conjecture,conjecture,(
    ! [X: $i,Y: $i,Z: $i] : imply(p(X,Y) & p(X,Z),Y = Z) )).
%------------------------------------------------------------------------------
\end{verbatim}
\end{small}
\caption{Implication is a function}
\label{ImplicationFunction}
\end{figure}

Figure~\ref{TupleConditionalLet} shows how tuples, conditional expressions, 
and let expressions can be mixed in useful ways, here to place two integer
values in descending order as arguments in an atom.

\begin{figure}[htbp]
\begin{small}
\begin{verbatim}
%------------------------------------------------------------------------------
tff(v1_type,type,v1: $int).

tff(v2_type,type,v2: $int).

tff(ordered_p,axiom,
    $let([large: $int,small: $int],
         [large,small]:= $ite($greater(v1,v2),[v1,v2],[v2,v1]),
         p(large,small)) ).
%------------------------------------------------------------------------------
\end{verbatim}
\end{small}
\caption{Mixing tuples, conditional and let expressions}
\label{TupleConditionalLet}
\end{figure}

Figure~\ref{LetITE} shows the TFX encoding of the FOOL formula in
Figure~\ref{fig:simple-if}, which expresses a partial correctness property 
of an imperative program with an \texttt{if} statement.

\begin{figure}[htbp]
\begin{small}
\begin{verbatim}
%------------------------------------------------------------------------------
tff(x,type,x:$int).
tff(y,type,y:$int).
tff(t,type,t:$int).
tff(x_leq_y,conjecture,
    $let([x:$int,y:$int,t:$int],
         [x,y,t] := $ite($greater(x,y),
                         $let(t:$int, t := x,
                         $let(x:$int, x := y,
                         $let(y:$int, y := t,
                              [x,y,t]))),
                         [x,y,t]),
         $lesseq(x,y))).
%------------------------------------------------------------------------------
\end{verbatim}
\end{small}
\caption{A TFX encoding of a program analysis problem on Figure
\ref{fig:simple-if}.}
\label{LetITE}
\end{figure}

Figure~\ref{Truthteller} shows an example that uses formulae as terms, in
the second arguments of the {\tt says} predicate.
The problem is to find a model, from the it is possible to determine which
of {\tt A},{\tt B}, or {\tt C} is the only truthteller on this
Smullyanesque island \cite{Smu78}.

\begin{figure}[htbp]
\begin{small}
\begin{verbatim}
%------------------------------------------------------------------------------
tff(a_type,type, a: $i ).
tff(b_type,type, b: $i ).
tff(c_type,type, c: $i ).
tff(exactly_one_truthteller_type,type, exactly_one_truthteller: $o ).
tff(says,type, says: ( $i * $o ) > $o ).

%----Each person is either a truthteller or a liar
tff(island,axiom,
    ! [P: $i] :
      ( says(P: $i,$true) <~> says(P: $i,$false) ) ).
tff(exactly_one_truthteller,axiom,
    ( exactly_one_truthteller
  <=> ( ? [P: $i] : says(P,$true)
      & ! [P1: $i,P2: $i] :
          ( ( says(P1,$true) & says(P2,$true) )
         => P1 = P2 ) ) )).

%----B said that A said that there is exactly one truthteller on the island
tff(b_says,hypothesis, says(b,says(a,exactly_one_truthteller)) ).

%----C said that what B said is false
tff(c_says,hypothesis, says(c,says(b,$false)) ).
%------------------------------------------------------------------------------
\end{verbatim}
\end{small}
\caption{Who is the truthteller?}
\label{Truthteller}
\end{figure}

%------------------------------------------------------------------------------
\section{Conclusion}
\label{Conclusion}

This paper has introduced the Typed First-order eXtended form (TFX) of the
TPTP's TFF syntax.
TFX includes formulae as terms, use of variables of the boolean type as
formulae, tuple terms and tuple types, conditional expressions,
and let expressions.
TFX is useful for (at least) concisely expressing problems coming from 
program analysis, and translated from more expressive logics.

Now that the syntax is settled, ATP system developers will be able to
implement the new language features.
It is already apparent from the SMT community that these are useful features,
and systems that can already parse the SMT syntax need only new parsers (for
TFX syntax) to implement the features.
In parallel, version v8.0.0 of the TPTP will include problems that use TFX,
and the automated reasoning community is invited to submit problems for
inclusion in the TPTP.

\paragraph{Acknowledgements.}
Thanks to our friends in the TPTP World, who have provided feedback on TFX
features, starting from the TPTP Tea Party at CADE-22 in 2009!

%------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{Bibliography}
%------------------------------------------------------------------------------
\end{document}
%------------------------------------------------------------------------------
